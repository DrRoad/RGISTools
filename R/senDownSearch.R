#' Download Sentinel images from search function
#'
#' \code{senDownSearch} downloads the list of urls generated by the function senSearch using the ESA’s SciHub API.
#'
#' \code{senDownSearch} downloads Sentinel images using the search results provided by \code{\link{senSearch}}.
#'  Images are downloaded into the \code{AppRoot} directory. In case the download is interrupted,
#'  the image file could be corrupted. The function detects the corrupted files to restart the process.
#'  To prevent the computer from crashing, the nattempts  flag limits the number of attempts to download the image.
#'  The default number of attempts is set to 3.
#' \code{senDownSearch} requires the credentials to access the ESA’s SciHub data service.
#' \href{https://scihub.copernicus.eu/dhus/#/self-registration}{Get your credentials}.
#'
#' @param searchres output from \code{\link{senSearch}} function.
#' @param username login credentials to access the ESA’s SciHub web service.
#' @param password login credentials to access the ESA’s SciHub web service.
#' @param unzip logical argument. If \code{TRUE}, unzips the images.
#' @param overwrite logical argument. If \code{TRUE}, overwrites the existing images with the same name.
#' @param nattempts the number of attempts that the function has to carry out to download an image in case of corrupted files.
#' @param error.log the name of the error log.
#' @param ... argument for function nestering.
#' \itemize{
#'   \item \code{AppRoot} the directory to save the output time series.
#' }
#'
#' @examples
#' \dontrun{
#' # load a spatial polygon object of Navarre
#' data(ex.navarre)
#' # Download S2MSI1C products sensed by Sentinel - 2 satellite in July-August 2018
#' searchres <- senSearch(startDate = as.Date("2018-07-29","%Y-%m-%d"),
#'                        endDate = as.Date("2018-08-06","%Y-%m-%d"),
#'                        platform = "Sentinel-2",
#'                        extent = ex.navarre,
#'                        product = "S2MSI1C",
#'                        username = "username",
#'                        password = "password")
#'
#' # filtering the path R094 where Navarre is located
#' names(searchres)
#' searchres.R094 <- searchres[grepl("R094", names(searchres))]
#' names(searchres.R094)
#' # list the dates in searchres
#' senGetDates(names(searchres.R094),format="%Y%J")
#' src = file.path("Path_for_downloading_folder","Sentinel-2")
#' # Sentinel download function
#' senDownSearch(searchres = searchres.R094,
#'               username = "username",
#'               password = "password",
#'               AppRoot = src,
#'               unzip = TRUE)
#' src.unzip <- file.path(src,"unzip")
#' files<-list.files(src.unzip,
#'                   pattern = "\\TCI.jp2$",
#'                   full.names = TRUE,
#'                   recursive = TRUE)
#' rgb<-stack(files[1])
#' plotRGB(rgb)
#' }
senDownSearch<-function(searchres,
                        username=NULL,
                        password=NULL,
                        error.log = "Sentinel_error.log",
                        nattempts = NULL,
                        unzip=FALSE,
                        overwrite=FALSE,
                        ...){
  arg<-list(...)
  if(is.null(username)|is.null(password)){
    stop("Username and/or password not defined!")
  }
  AppRoot<-defineAppRoot(...)
  downFolder<-file.path(AppRoot,"/raw")
  dir.create(downFolder,recursive=T,showWarnings = FALSE)
  if(unzip){
    unzipFolder<-file.path(AppRoot,"/unzip")
    dir.create(unzipFolder,recursive=T,showWarnings = FALSE)
  }
  n.imgs<-length(searchres)
  for(i in 1:n.imgs){
    url<-searchres[i]
    file.name<-names(url)
    tryCatch({
      downPath<-file.path(downFolder,paste0(file.name,".zip"))
      if((!file.exists(downPath))|overwrite){
        message(paste0("Downloading image ",file.name," (",i,"/",n.imgs,")"))
        c.handle = new_handle()
        handle_setopt(c.handle,
                      referer=getRGISToolsOpt("SCIHUBHUSURL"),
                      useragent = getRGISToolsOpt("USERAGENT"),
                      followlocation = TRUE ,
                      autoreferer = TRUE ,
                      username=username,
                      password=password)
        image.url<-URLencode(url)
        
        curl_download(image.url, destfile=downPath,handle = c.handle)
      }

      #md5 check
      md5.url<-paste0(gsub("$value","",url,fixed = TRUE),"Checksum/Value/$value")
      print(md5.url)
      repeat{
        response<-curl(md5.url,handle =c.handle)
        md5.text<-readLines(response)
        if(!grepl("Error",md5.text)){
          print(paste0("Get md5: ",md5.text))
          break
        }else{
          message("md5 not found! trying again.")
          Sys.sleep(10)
        }
      }
      if(!genCheckMD5(downPath,oficial.md5=md5.text)){
        cat(paste0("Error cheking ",file.name," file md5: ",md5.text),file=error.log,sep="\n",append = T)
        file.remove(downPath)
        senDownSearch(username,password,url,file.path,file.name,error.log,AppRoot=AppRoot,nattempts +1)
      }else{
        print(paste0("OK: cheking ",file.name," file md5."))
        if(unzip){
          message("Unzipping ", basename(downPath)," file.")
          unzip(zipfile=downPath,
                exdir = unzipFolder,
                overwrite=overwrite)
        }
      }
    }, error = function(e) {
      print(paste0("ERROR:",e))
      close(file)
      cat(file.name,file=error.log,sep="\n",append = TRUE)
      file.remove(downPath)
      senDownSearch(username,password,url,file.path,error.log,AppRoot=AppRoot,nattempts +1)
    }, finally = {
    })
  }

  if(unzip){
    message(paste0("The images have been unzipped in: ",unzipFolder))
  }else{
    message(paste0("The images have been downloaded and saved on HDD. \nFile path: ",downFolder))
  }
}
